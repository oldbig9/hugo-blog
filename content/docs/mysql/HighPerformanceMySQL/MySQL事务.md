---
weight: 999
title: "MySQL事务"
description: "抄书笔记"
icon: "article"
date: "2023-10-11T16:11:36+08:00"
lastmod: "2023-10-11T16:11:36+08:00"
draft: false
toc: true
---

## 事务的特性(ACID)

| 特性                | 描述                                                                                                                                                                     |
| :------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 原子性(atomicity)   | 一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作，要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中一部分操作，这就是事务的原子性 |
| 一致性(consistency) | 数据库总是从一个一致性的状态转换到另一个一致性的状态                                                                                                                     |
| 隔离性(isolation)   | 通常来说一个事务所做的修改在最终提交之前，对其他事务是不可见的。但也与隔离级别有关                                                                                       |
| 持久性(durability)  | 一旦事务提交，则其所做的修改就会永久保存到数据库中                                                                                                                       |

## 事务隔离级别

### 隔离级别

| 级别                       | 脏读   | 不可重复读 | 幻读   | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| :------------------------- | :----- | :--------- | :----- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 读未提交(Read Uncommitted) | 可能   | 可能       | 可能   | 在读未提交级别中，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读(Dirty Read)。实际场景中很少用                                                                                                                                                                                                                                                                                                               |
| 读已提交(Read Committed)   | 不可能 | 可能       | 可能   | 大多数数据库系统的默认隔离级别都是读已提交，但 MySQL 不是。读已提交满足隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做“**不可重复读(Nonrepeatable Read)**”，因为两次执行同样的查询，可能会得到不一样的结果                                                                                                                            |
| 可重复读(Repeatable Read)  | 不可能 | 不可能     | 可能   | 可重复读解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读还是无法解决另外一个幻读(Phantom Read)的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行(Phatan Row)。InnoDB 和 XtraDB 存储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control)解决了幻读的问题。**可重复读是 MySQL 的默认事务隔离级别** |
| 串行化(Serializable)       | 不可能 | 不可能     | 不可能 | 串行化是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，串行化会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别                                                                                                                                                  

### 查看隔离级别
```SQL
# 查看系统隔离级别
mysql> select @@global.tx_isolation;
+-----------------------+
| @@global.tx_isolation |
+-----------------------+
| REPEATABLE-READ       |
+-----------------------+

# 查看会话隔离级别5.0以上版本
mysql> select @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+

# 查看会话隔离级别8.0以上版本
mysql> select @@transaction_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
``` 

### 设置隔离级别
```SQL
set session transaction isolation level read uncommitted;
set session transaction isolation level read committed;
set session transaction isolation level repeatable read;
```

## 事务导致死锁的问题

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图已不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。死锁发生后只有部分或者完全回滚其中一个事务，才能打破死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。


## 隐式锁定和显示锁定

InnoDB采用的是两阶段锁定协议(two-phase locking protocol)。在事务执行过程中，随时都可以执行锁定，锁只有在执行commit或rollback的时候才会释放，并且所有的锁都适合在同一时刻释放。前面描述的锁都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。

另外InnoDB也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范
```SQL
select ... lock in share mode
select ... for update
```

MySQL也支持lock tables和unlock tables语句，这是在服务器层实现的，和存储引擎无关。